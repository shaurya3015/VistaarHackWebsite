<!DOCTYPE html>
<!-- Add dark class here to set dark mode by default, or leave it off for light mode default -->
<html lang="en"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive PDF Reader</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load pdf.js library from CDN -->
    <!-- We need both the main library and the worker -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* This container holds both the canvas and the text layer */
        #pdf-render-area {
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* The canvas is the base layer */
        #pdf-canvas {
            width: 100%;
            height: auto;
            border-radius: 8px;
        }

        /* The text layer sits *exactly* on top of the canvas */
        /* This is what allows us to select text */
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            opacity: 0; /* Set to 0 for production, text is invisible but selectable */
            color: transparent; /* Text is invisible, but selectable */
            line-height: 1;
        }

        .textLayer ::selection {
            background: rgba(0, 100, 255, 0.3); /* Custom highlight color */
        }

        /* pdf.js-specific styling for text layer spans */
        .textLayer > span {
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        /* Simple loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* This class is no longer needed, as we're using 
          Tailwind's 'dark:' prefixes directly.
        */
        /*
        .pdf-dark-mode {
            filter: invert(1) hue-rotate(180deg);
            background-color: #f8f8f8;
        }
        */
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 shadow-md w-full z-10">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800 dark:text-gray-200">Smart PDF Reader</h1>
            <!-- Added a container for the buttons -->
            <div class="flex items-center space-x-4">
                <button id="dark-mode-toggle" class="bg-gray-600 text-white px-4 py-2 rounded-md font-semibold cursor-pointer hover:bg-gray-700 transition duration-200">
                    Toggle Dark Mode
                </button>
                <label for="pdf-upload" class="bg-blue-600 text-white px-4 py-2 rounded-md font-semibold cursor-pointer hover:bg-blue-700 transition duration-200">
                    Upload PDF
                </label>
            </div>
            <input type="file" id="pdf-upload" class="hidden">
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">

        <!-- PDF Viewer Column -->
        <div id="pdf-viewer-container" class="flex-1 flex flex-col items-center justify-center p-4 overflow-y-auto bg-gray-200 dark:bg-gray-700">
            
            <!-- PDF Loading Message -->
            <div id="pdf-loading-message" class="text-center text-gray-600 dark:text-gray-400">
                <svg class="mx-auto h-12 w-12 text-gray-400 dark:text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-900 dark:text-gray-100">Upload a PDF</h3>
                <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">Select a well-formatted paper or book to begin.</p>
            </div>

            <!-- PDF Pagination -->
            <div id="pdf-pagination-controls" class="hidden my-4 p-2 bg-white dark:bg-gray-800 rounded-md shadow-sm flex items-center space-x-4">
                <button id="prev-page" class="px-4 py-2 bg-gray-200 dark:bg-gray-600 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 disabled:opacity-50" disabled>&larr; Prev</button>
                <span id="page-num" class="text-gray-700 dark:text-gray-300 font-medium">Page <span id="current-page-num">1</span> of <span id="total-page-num">1</span></span>
                <button id="next-page" class="px-4 py-2 bg-gray-200 dark:bg-gray-600 dark:text-gray-200 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 disabled:opacity-50" disabled>Next &rarr;</button>
            </div>

            <!-- PDF Content Renders Here -->
            <!-- We apply the dark mode filter directly using Tailwind's 'dark:' prefix -->
            <div id="pdf-render-area" class="rounded-lg dark:filter dark:invert(1) dark:hue-rotate(180deg)">
                <!-- Canvas for PDF rendering -->
                <canvas id="pdf-canvas"></canvas>
                <!-- Text layer for text selection (sits on top of canvas) -->
                <div id="pdf-text-layer" class="textLayer"></div>
            </div>
        </div>

        <!-- Chat Column -->
        <div id="chat-container" class="w-full md:w-1/3 lg:w-1/4 h-1/2 md:h-full flex flex-col bg-white dark:bg-gray-800 border-l border-gray-300 dark:border-gray-600">
            <!-- Message List -->
            <div id="message-list" class="flex-1 p-4 overflow-y-auto space-y-4">
                <!-- Initial Bot Message -->
                <div class="flex">
                    <div class="p-3 bg-gray-200 dark:bg-gray-700 rounded-lg max-w-xs">
                        <p class="text-sm text-gray-800 dark:text-gray-200">Hello! Upload a PDF, then highlight any text to get started. You can ask me to explain concepts, summarize sections, and more.</p>
                    </div>
                </div>
            </div>
            
            <!-- Chat Input -->
            <div class="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
                <div class="flex space-x-2">
                    <textarea id="chat-input" rows="2" class="flex-1 p-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-200 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400" placeholder="Ask a follow-up..."></textarea>
                    <button id="send-button" class="px-4 py-2 bg-blue-600 text-white rounded-md font-semibold hover:bg-blue-700 transition duration-200">Send</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Context Menu (Hidden by default) -->
    <div id="context-menu" class="hidden absolute z-50 bg-white dark:bg-gray-700 shadow-lg rounded-md overflow-hidden border border-gray-200 dark:border-gray-600">
        <button id="explain-button" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">Explain This</button>
        <button id="ask-button" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">Ask About This</button>
    </div>

    <!-- JavaScript Application Logic -->
    <script type="module">
        // --- Gemini API Configuration ---
        // NOTE: The API key is an empty string. Canvas will handle authentication.
        const apiKey = ""; 
        const model = "gemini-2.5-flash-preview-09-2025";
        // *** FIX: Corrected 'generativelace' to 'generativelanguage' ***
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

        // --- PDF.js Configuration ---
        // Set the path to the worker script
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // --- Application State ---
        let pdfDoc = null;
        let currentPageNum = 1;
        let currentSelection = "";
        let chatHistory = [];
        let isRendering = false; // Prevent race conditions on render

        // --- DOM Elements ---
        const fileInput = document.getElementById('pdf-upload');
        const pdfContainer = document.getElementById('pdf-viewer-container');
        const renderArea = document.getElementById('pdf-render-area');
        const canvas = document.getElementById('pdf-canvas');
        const textLayerDiv = document.getElementById('pdf-text-layer');
        const ctx = canvas.getContext('2d');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const currentPageEl = document.getElementById('current-page-num');
        const totalPageEl = document.getElementById('total-page-num');
        const paginationControls = document.getElementById('pdf-pagination-controls');
        const loadingMessage = document.getElementById('pdf-loading-message');
        
        // --- New DOM Element ---
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        
        const contextMenu = document.getElementById('context-menu');
        const explainBtn = document.getElementById('explain-button');
        const askBtn = document.getElementById('ask-button');
        
        const messageList = document.getElementById('message-list');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-button');

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileUpload);
        prevPageBtn.addEventListener('click', onPrevPage);
        nextPageBtn.addEventListener('click', onNextPage);
        
        // --- Updated Event Listener ---
        darkModeToggle.addEventListener('click', toggleAppDarkMode);

        // Listen for text selection in the PDF area
        pdfContainer.addEventListener('mouseup', handleTextSelection);
        // Hide context menu if clicking elsewhere
        document.addEventListener('mousedown', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.add('hidden');
            }
        });

        // --- Updated Function for Dark Mode ---
        // This function now toggles dark mode for the *entire* app
        function toggleAppDarkMode() {
            document.documentElement.classList.toggle('dark');
        }

        // --- PDF Loading and Rendering ---
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file || file.type !== 'application/pdf') return;

            // Reset UI
            pdfDoc = null;
            currentPageNum = 1;
            loadingMessage.classList.add('hidden');
            paginationControls.classList.remove('hidden');
            addMessageToUI('bot', 'New document loaded. Ready for your questions!');
            chatHistory = [];
            
            const fileReader = new FileReader();
            fileReader.onload = async (ev) => {
                const typedarray = new Uint8Array(ev.target.result);
                try {
                    const loadingTask = pdfjsLib.getDocument({ data: typedarray });
                    pdfDoc = await loadingTask.promise;
                    totalPageEl.textContent = pdfDoc.numPages;
                    renderPage(currentPageNum);
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    addMessageToUI('bot', `Sorry, I couldn't load that PDF. Error: ${error.message}`);
                    loadingMessage.classList.remove('hidden');
                    paginationControls.classList.add('hidden');
                }
            };
            fileReader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            if (isRendering || !pdfDoc) return;
            isRendering = true;
            
            currentPageNum = num;
            currentPageEl.textContent = num;
            
            // Disable buttons during render
            prevPageBtn.disabled = (num <= 1);
            nextPageBtn.disabled = (num >= pdfDoc.numPages);

            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale: 1.5 });
                
                // Set canvas dimensions
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Set text layer dimensions
                textLayerDiv.style.width = `${viewport.width}px`;
                textLayerDiv.style.height = `${viewport.height}px`;
                
                // Clear previous text layer content
                while (textLayerDiv.firstChild) {
                    textLayerDiv.removeChild(textLayerDiv.firstChild);
                }

                // Render PDF page into canvas context
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport
                };
                const renderTask = page.render(renderContext);
                
                // Get text content to render the selectable text layer
                const textContent = await page.getTextContent();
                
                // Render the text layer
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });

                await renderTask.promise;
                
            } catch (error) {
                console.error('Error rendering page:', error);
            } finally {
                isRendering = false;
            }
        }

        function onPrevPage() {
            if (currentPageNum <= 1) return;
            renderPage(currentPageNum - 1);
        }

        function onNextPage() {
            if (currentPageNum >= pdfDoc.numPages) return;
            renderPage(currentPageNum + 1);
        }

        // --- Text Selection & Context Menu ---
        function handleTextSelection(e) {
            // Only show menu if we're not clicking on the menu itself
            if (contextMenu.contains(e.target)) return;
            
            const selection = window.getSelection().toString().trim();
            if (selection.length > 5) { // Only show for reasonably long selections
                currentSelection = selection;
                contextMenu.style.top = `${e.pageY + 5}px`;
                contextMenu.style.left = `${e.pageX + 5}px`;
                contextMenu.classList.remove('hidden');
            } else {
                currentSelection = "";
                contextMenu.classList.add('hidden');
            }
        }

        function handleExplainClick() {
            if (!currentSelection) return;
            const query = `Explain this highlighted text: "${currentSelection}"`;
            handleChatSubmit(currentSelection, query, true); // true = user msg is the query
            contextMenu.classList.add('hidden');
        }
        
        function handleAskClick() {
            chatInput.value = `Based on the text "${currentSelection}", `;
            chatInput.focus();
            contextMenu.classList.add('hidden');
        }

        // --- Chat & Gemini API Logic ---
        function handleChatSend() {
            const query = chatInput.value.trim();
            if (!query) return;
            
            // Use currentSelection if it was just added to the input
            let context = currentSelection;
            if (!query.includes(currentSelection)) {
                context = ""; // User is asking a general follow-up, not about the selection
            }
            
            handleChatSubmit(context, query, true);
            chatInput.value = "";
        }

        async function handleChatSubmit(contextText, query, showUserMessage = true) {
            if (showUserMessage) {
                addMessageToUI('user', query);
                chatHistory.push({ role: 'user', parts: [{ text: query }] });
            }
            
            const loadingEl = addMessageToUI('bot', '', true); // Show loading spinner
            
            try {
                const aiResponse = await callGeminiAPI(contextText, query, chatHistory.slice(0, -1)); // Send history *before* this query
                
                // Update loading message with real response
                loadingEl.querySelector('p').textContent = aiResponse;
                loadingEl.querySelector('.loader')?.remove(); // Remove spinner
                
                chatHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                
            } catch (error) {
                console.error('Gemini API Error:', error);
                loadingEl.querySelector('p').textContent = `Sorry, I hit an error: ${error.message}`;
                loadingEl.querySelector('.loader')?.remove();
            }
        }

        function addMessageToUI(role, text, isLoading = false) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'flex';
            
            let content;
            if (role === 'user') {
                msgDiv.classList.add('justify-end');
                content = `
                    <div class="p-3 bg-blue-600 rounded-lg max-w-xs">
                        <p class="text-sm text-white">${text}</p>
                    </div>
                `;
            } else { // 'bot'
                msgDiv.classList.add('justify-start');
                // *** FIX: Added dark mode classes for bot messages ***
                content = `
                    <div class="p-3 bg-gray-200 dark:bg-gray-700 rounded-lg max-w-xs">
                        ${isLoading 
                            ? `<div class="flex items-center space-x-2"><div class="loader"></div><p class="text-sm text-gray-600 dark:text-gray-300">Thinking...</p></div>` 
                            : `<p class="text-sm text-gray-800 dark:text-gray-200">${text}</p>`
                        }
                    </div>
                `;
            }
            
            msgDiv.innerHTML = content;
            messageList.appendChild(msgDiv);
            
            // Scroll to bottom
            messageList.scrollTop = messageList.scrollHeight;
            
            // Return the bot message element if we need to update it later
            if (role === 'bot') {
                return msgDiv.querySelector('.p-3');
            }
        }

        async function callGeminiAPI(contextText, query, history) {
            // Construct the prompt
            let systemPrompt = "You are an expert assistant for reading dense academic papers. Be concise and clear. The user will provide highlighted text and ask questions. Base your answers on the provided text and conversation history.";
            
            let userPrompt = "";
            if (contextText) {
                userPrompt += `--- HIGHLIGHTED TEXT ---\n${contextText}\n---\n\n`;
            }
            userPrompt += `User's Question: ${query}`;

            // We combine system prompt, history, and new query
            const contents = [
                ...history,
                { role: 'user', parts: [{ text: userPrompt }] }
            ];
            
            const payload = {
                contents: contents,
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            
            // --- API Call with Retry Logic ---
            let response;
            let retries = 3;
            let delay = 1000;
            
            while (retries > 0) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const candidate = result.candidates?.[0];
                        if (candidate && candidate.content?.parts?.[0]?.text) {
                            return candidate.content.parts[0].text;
                        } else {
                            throw new Error('Invalid API response structure.');
                        }
                    } else if (response.status === 429) { // Throttling
                        console.warn(`API throttling. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                        retries--;
                    } else {
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                    retries--;
                    if (retries <= 0) {
                       throw error; // Give up
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
            throw new Error('API call failed after retries.');
        }

    </script>
</body>
</html>



